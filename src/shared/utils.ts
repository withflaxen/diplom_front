export function parseFunction(code:string) {
    // создаем пустой объект для результата
    let result = {} as {args:string[],body:string};
    // создаем регулярное выражение для поиска объявления функции через const или function
    let regex1 = /(?:const|function)\s+(\w+)\s*\((.*?)\)\s*\{(.*?)\}/s;
    // создаем регулярное выражение для поиска объявления функции через стрелку
    let regex2 = /const\s+(\w+)\s*=\s*\((.*?)\)\s*=>\s*\{(.*?)\}/s;
    // пробуем найти совпадение в исходном коде с первым регулярным выражением
    let match1 = regex1.exec(code);
    // пробуем найти совпадение в исходном коде со вторым регулярным выражением
    let match2 = regex2.exec(code);
    if (match1) {
        // если нашли совпадение с первым регулярным выражением, то извлекаем из него имя функции, аргументы и тело
        let name = match1[1];
        let args = match1[2];
        let body = match1[3];
        // добавляем к результату поле args, которое содержит массив строк с именами аргументов
        result.args = args.split(",").map((arg) => arg.trim());
        // добавляем к результату поле body, которое содержит строку с телом функции
        result.body = body;
    } else if (match2) {
        // если нашли совпадение со вторым регулярным выражением, то извлекаем из него имя функции, аргументы и тело
        let name = match2[1];
        let args = match2[2];
        let body = match2[3];
        // добавляем к результату поле args, которое содержит массив строк с именами аргументов
        result.args = args.split(",").map((arg) => arg.trim());
        // добавляем к результату поле body, которое содержит строку с телом функции
        result.body = body;
    } else {
        // если не нашли совпадение ни с одним из регулярных выражений, то возвращаем null
        return null;
    }
    // возвращаем результат
    return result;
}